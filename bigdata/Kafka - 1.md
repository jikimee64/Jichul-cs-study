## Kafka 개념

### 등장 배경
- 카프카는 비동기 처리를 위한 메시징 큐의 한 종류로써, 링크드인에서 생성되는 로그를 처리하여 웹사이트 활동을 
추적하는 것을 목적으로 개발되었다.
- 다른 의미로 이벤트 스트리밍 플랫폼이라고도 불린다. 이벤트 스트림은 연속적인 많은 Event들의 흐름을 의미한다
- 웹에서 생성되는 대량의 로그를 분석하여 사용자가 웹에서 하는 활동을 모니터링하고 서비스 개선에 활용 하고자 했다.
- 당시 아래와 같은 4가지의 목표를 잡았다.

**높은 처리량으로 실시간 처리**
- 전 세계 사용자의 방대한 액세스 데이터를 처리해야 하기 때문에 처리량이 우수해야 한다.
- 사용자의 활동을 신속하게 파악하거나 사용자의 활동에 따라 즉각 피드백을 하기 위해서는 사용자의 활동
단위로 실시간처리가 가능해야 한다.

**임의의 타이밍에서 데이터를 읽기**
- 수집한 액세스 로그를 일정 시간마다 배치 처리 하기를 원했다.
- 데이터를 사용하는 타이밍이 용도에 따라 실시간이 아닐수도 있기 때문에 버퍼역할을 원했으므로 데이터 축적
시간이 길어야 했다.

**다양한 제품과 시스템에 쉽게 연동**
- 여러 목적으로 사용하고 있던 시스템(DB, 하둡, 데이터 웨어하우스를)과의 연결을 쉽게 하고 싶었다.

**메시지 유실 방지**
- 메시지가 방대하더라도 메시지를 유실하면 안됨
- 중복메시지가 있을지 언정 메시지 유실을 막는 것이 중요했다.
- 위와 같은 요구사항을 만족하는 제품이 2009년에는 없었기 때문에 자체 개발 했다.
- 카프카의 핵심은 **메시징 모델과 스케일 아웃형 아키텍처**와 **디스크로의 데이터 영속화**다.
- 메시징 모델과 스케일 아웃형 아키텍처
  - 기존의 메시징 모델인 큐잉모델과 펍/섭 메시징 모델의 장점을 갖추고 있다.
  - 큐잉 모델에서 여러 컨슈머가 분산처리로 메시지를 소비하는 점과, 펍/섭 메시지 모델에서 실현한 여러
  Subscriber에 같은 메시지를 전달하고, 토픽 기반으로 전달 내용을 변경하는 모델을 모두 채택했다.
  - 해당 모델을 실현하기 위해 '컨슈머 그룹'을 도입하여 컨슈머를 확장할 수 있도록 설계했다.
  - 여러 컨슈머가 같은 토픽을 분산하여 메시지를 읽음으로써 처리의 확장성을 담보
  - 카프카 클러스터링으로 브로커를 복수 구성 할 수 있다.
- 디스크로의 데이터 영속화
  - 메시지 유실 방지를 위한 디스크로의 영속화

- 과거 링크드인 시스템
  ![Untitled](https://media.vlpt.us/images/busybean3/post/f3df037a-a57b-40fc-b0b3-cad5ca3eba77/image.png)
- 카프카를 이용한 링크드인 시스템
  ![Untitled](https://media.vlpt.us/images/busybean3/post/72e61377-c12d-4f6a-97bc-8c139ebdc766/image.png)

### Kafka 실무 사례 예시
- 로그 수집용
  ex) 여러 msa에서 발생하는 로그를 카프카로 전송 -> 컨슈머에서 수집해서 ES나 하둡에 저장하여 로그 확인
- 비동기 이벤트 발생()
  ex) 주문상태 변경 -> 주문상태 변경 메시지를 produce -> 해당 토픽을 컨슘하고 있던 consumer들은 주문상태가 
  변경되었을 떄 처리해야하는 로직 수행
  - 래빗엠큐 등 다른 종류의 메시지 큐를 사용해도 되지만 보통 카프카를 쓰던 팀에서는 카프카로 구현한다고 한다.

### 메시지 큐의 RabbitMQ 브로커 방식
![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc1jNIo%2FbtqF3Gz7CXx%2FE5DgxajmcBCNjN25eELvhK%2Fimg.png)
- 기존 Client <-> Server 의 통신방식은 Client 요청이 증가할 경우 느려질 수 있고 확장성이 떨어진다
- 서버에서 장애가 생겨 요청을 처리하지 못하게 되면 메시지가 유실될 수 있다.
- 이벤트 큐 모델 등장
- 프로듀서가 메시지를 컨슈머에게 직접 전달하는 것이 아니라, 중간의 메시징 시스템에 전달

#### RabbitMQ 작동방식 
- 프로듀서는 Message를 Exchange에게 보냄(Exchange를 생성할때 Exchange의 type을 정해야함)
- exchange는 라우팅 키를 사용하여 적절한 큐로 라우팅을 진행(라우팅은 exchange type에 따라 전략이 바뀜)
- 큐에 바인딩 된 메시지는 컨슈머가 소비할때 까지 큐에 대기
- exchange는 정해진 규칙으로 메시지를 라우팅하는 기능을 가지고 있음
  ![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJPTB4%2FbtqF2RB74O0%2FL6kDxo3khmIwGU5TVkBCb0%2Fimg.png)
  - Direct Exchange: 메시지의 라우팅 키와 정확히 일치하는 바인딩된 큐로 라우팅
  - Fanout Exchange: 바인딩된 모든 큐에 메시지를 라우팅
  - Topic Exchange: 특정 라우팅 패턴이 일치하는 큐로 라우팅
  - Headers Exchange: key-value로 정의된 Header 속성을 통한 라우팅

- 장점
    - 컨슈머가 장애가 발생한 경우에도 문제가 발생되지 않으며, 컨슈머를 재가동하면 큐에 있는 메시지를 가져갈 수 있다.
    - 메시징 시스템만 살아 있다면 메시지도 유실되지 않고, 확장성도 용이
- 단점
    - 직접 통신하지 않기 때문에 메시지가 잘 전달되었는지 파악하기 복잡
    - 중간에 메시징 시스템을 거치기 때문에 메시지 전달 속도가 느림
    
### 카프카의 Pub/Sub 기반 메시징 시스템
![Untitled](https://camo.githubusercontent.com/d008556df9b0947f7f36f7f940a6a1c6aa337d317c57f6b240d6735026cdf402/68747470733a2f2f6d656469612e766c70742e75732f696d616765732f6a61656879656f6e672f706f73742f32613931346365312d396338362d343638342d386631352d3233313436656261356661372f556e7469746c6564253230342e706e67)
#### 간단 용어
- 프로듀서
  - 메시지를 생산해서 브로커의 토픽으로 메시지를 보내는 역할
- 브로커
  - 카프카가 설치된 서버
  - 기본적으로 3개 이상의 브로커서버를 하나의 카프카 클러스터로 묶어서 운영해야 최소의 안정성 확보 가능
- 컨슈머
  - 브로커의 토픽으로부터 저장된 메시지를 전달받는 역할
- 주키퍼
  - 분산된 카프카의 정보를 관리하는 역할 수행

#### 추천하는 이유
- 이유1
  ![Untitled](https://camo.githubusercontent.com/ad5d3cd6d65b1ae5893b5157af9adec1022cc50bcf7ecb6ba1e6139f4f74ebd4/68747470733a2f2f6d656469612e766c70742e75732f696d616765732f6a61656879656f6e672f706f73742f31626630373966612d643761652d343031392d383265352d3465633636636562346466382f556e7469746c6564253230352e706e67)
  - 잔여 메모리를 이용해 디스크 Read/Write를 하지 않고 OS에서 제공하는 페이지 캐시를 사용해서 파일에 대한
  IO를 메모리에서 처리함으로써 I/O 속도가 빨라짐
  - but, 페이지 캐시를 카프카만 사용해야 성능에 유리
- 이유2
  - 제로카피를 사용하여 네트워크 전송속도 증가
  - 디스크 버퍼에서 네트워크 버퍼로 직접 데이터 복사
  ※ 제로카피란 디스크에 있는 데이터를 네트워크로 전송할 때 일어나느 바이트 카피를 최소화 하는 작업
- 이유3
  - 메시지 필터링, 재전송 같은 작업을 브로커가 하지 않고 프로듀서와 컨슈머가 담당
  - 브로커가 컨슈머에 대해서 별로 하는일이 없어 더 빨리 동작
  - 브로커는 단순히 컨슈머와 파티션 간 매핑 관리
- 이유4
  - 메시지를 작은 단위로 묶어 배치 처리를 할 수 있다.
  - 작은 단위로 계속 보내고 받는것보다 쳐리량을 높힐수 있음
- 이유5
  - 수평 확장 용이
  - 한개의 브로커에서 용량의 한계가 오면 브로커를 추가
  - 컨슈머에서 수행하는 역할이 느리면 컨슈머 추가(프로듀서도 마찬가지)

### RabbitMQ vs Kafka 
- 비교하기전에 메시지큐의 장점은 다음과 같다.
  - 비동기: Queue에 넣기 때문에 나중에 처리 가능
  - 비동조(디커플링): 각 어플리케이션을 느슨하게 연결
  - 탄력성: 일부가 실패해도 전체에 영향을 받지 않습니다.
  - 과잉: 실패할경우 재실행 가능
  - 보증: 작업처리 확인 가능
  - 확장성: 다수의 프로세스들이 큐에 메시지 전송 가능
  - 대용량의 데이터 처리를 위해 분산처리할 때 쓰인다.

#### RabbitMQ
- 인기 있는 AMQP 프로토콜을 기반으로 초기 구축되었으며, 기존 기술과의 호환성도 뛰어남
- 서버에서 사용할 수 있는 플러그인을 통해 기능 확장 용이
- 유연한 라우팅 가능
- producer/consumer간의 보장되는 메세지 전달에 초점
- 소비자 중심의 설계와 구성이 쉬움 
- 필요에 따라 동기/비동기 처리 가능

#### Kafka
- 처리량에 포커스를 맞춤
- 분산로그를 기반으로 해당 로그는 디스크에 보존된 로그의 끝에 메시지가 기록되고 클라이언트가 해당 로그에서
읽기 시작하는 위치 선택 가능
- Kafka 클러스터도 여러 서버에 분산 및 클러스터링하여 가용성을 높일 수 있음
- 생산자 중심의 설계로 구성
- 비동기식 구성, 고성능 방식

#### 선정 기준
**RabbitMQ**
  - 메시지 브로커인 RabbitMQ는 응용프로그램, 서비스 및 시스템이 정보를 통신하고 교환할 수 있도록 하는 
소프트웨어 모듈
  - 메시지 브로커는 지정된 수신인에게 메시지를 확인, 라우팅, 저장 및 배달
  - 브로커는 다른 응용 프로그램 간의 중개자로 작동하여 보낸 사람이 소비자의 위치, 활성 여부 또는 그 중 몇개가
  있는지도 모르게 메시지를 보낼 수 있다.
  - 신속한 요청-응답이 필요한 웹 서버에 적합, 또한 부하가 높은 작업자(20K 이상 메시지/초)간에 부하를 공유
  - 백그라운드 작업이나 PDF 변환, 파일 검색 또는 이미지 확장과 같은 장기 실행 작업 처리 가능
  - 애플리케이션간 내부통신 및 통합이 필요할 때 적절

**Kafka**
  - 펍/섭 방식인 Kafka는 생산자가 원하는 각 메시지를 게시할 수 있도록 하는 메시지 배포 패턴
  - 복잡한 라우팅에 의존하지 않고 최대 처리량으로 스트리밍하는데 가장 적합
  - 또한, 이벤트 소싱, 스트림 처리 및 일련의 이벤트로 시스템에 대한 모델링 변경을 수행하는데 이상적
  - 다단계 파이프라인에서 데이터를 처리하는 데도 적합
  - 스트리밍 데이터를 저장, 읽기, 다시 읽기 및 분석하는 프레임워크가 필요한 경우 사용
  - 정기적으로 감사하는 시스템이나 메시지를 영구적으로 저장하는데 이상적
  - 대용량의 분산 로그 트래픽 처리